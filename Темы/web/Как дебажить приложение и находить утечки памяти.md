
---

# Как дебажить приложение и находить утечки памяти

---

## Общий процесс дебага

1. **Определить проблему**  
   Приложение тормозит, зависает или потребляет слишком много памяти?  
   Используйте инструменты браузера:

   - DevTools (вкладки Performance, Memory)
   - Console
   - React Profiler

2. **Анализ логов и ошибок**  
   Добавляйте `console.log`, `console.trace`, `console.error` для отслеживания.  
   Используйте внешние сервисы для логирования ошибок: Sentry, LogRocket, Datadog.

3. **Профилирование производительности**

   - Вкладка Performance в Chrome DevTools — анализ FPS, времени загрузки и рендера.
   - React Profiler — для выявления лишних ререндеров компонентов.
   - Lighthouse — рекомендации по оптимизации.

4. **Анализ утечек памяти**
   - Вкладка Memory → Heap Snapshot для съёмки снимков памяти.
   - Ищите объекты, которые не удаляются после удаления компонента.
   - Следите за таймерами (`setInterval`, `setTimeout`), подписками (WebSocket, EventListeners).

---

## Причины утечек памяти и решения

### Забытые таймеры и интервалы

```js
useEffect(() => {
  const interval = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(interval); // обязательно очищаем!
}, []);
```

---

### Неудалённые обработчики событий

```js
useEffect(() => {
  const handleScroll = () => console.log('scrolling...');
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

---

### Замыкания, удерживающие данные

Замыкания могут запомнить ссылки на объекты, которые не будут удалены.  
Решение: использовать `useRef`, `useCallback` и своевременно очищать ресурсы.

---

### Глобальные переменные

```js
window.myCache = largeObject; // плохая практика
// Лучше явно очищать
window.myCache = null;
```

---

### Ссылки в useRef и DOM

```js
const ref = useRef(null);

useEffect(() => {
  ref.current = document.getElementById('my-element');
  return () => {
    ref.current = null; // освобождаем ссылку
  };
}, []);
```

---

### WebSocket и подписки

```js
useEffect(() => {
  const socket = new WebSocket('wss://example.com');
  return () => socket.close(); // обязательно закрываем
}, []);
```

---

### Отсутствие виртуализации на больших списках

Рендеринг 1000+ элементов без виртуализации сильно замедляет приложение и потребляет память.  
**Решение:** использовать библиотеки [react-window](https://github.com/bvaughn/react-window) или [react-virtualized](https://github.com/bvaughn/react-virtualized).

---

## Как найти утечки памяти

### Вкладка Memory → Heap Snapshot

- Сделайте снимок памяти в DevTools → Memory.
- Взаимодействуйте с компонентом (откройте/закройте модалку).
- Сделайте второй снимок.
- Сравните: временные объекты должны исчезнуть.

### Вкладка Performance → Record Allocations

- Запустите запись аллокаций.
- Используйте компонент.
- Остановите и ищите утечки объектов, оставшихся после удаления компонента.

---

## Инструменты мониторинга

- **Chrome DevTools** — встроенный анализатор памяти и профайлер
- **Sentry**, **Datadog**, **LogRocket** — обнаружение и логирование ошибок в продакшене
- **why-did-you-render** — помогает найти лишние ререндеры компонентов

---

## Вывод

- Следите за очисткой всех сайд-эффектов (`setInterval`, `event listeners`, `sockets`).
- Используйте DevTools → Memory → Snapshot для диагностики.
- Не храните глобальные объекты или замыкания без очистки.
- На больших списках применяйте виртуализацию.
- Используйте React Profiler и профилирование браузера, чтобы находить узкие места.

---

### Пример шаблона безопасного useEffect

```js
useEffect(() => {
  const res = startSomething();
  return () => {
    cleanupSomething(res);
  };
}, []);
```

---

Источник: [Как дебажить приложение и находить утечки памяти — hackfrontend](https://www.hackfrontend.com/docs/general-questions/how-to-debug-an-application-and-find-memory-leaks)

[1](https://www.hackfrontend.com/docs/general-questions/how-to-debug-an-application-and-find-memory-leaks)
