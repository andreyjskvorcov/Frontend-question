---
# Server-Sent Events, Polling и Long Polling: что это и когда использовать
---

## Что это вообще?

Все три технологии — способы получения данных с сервера в браузере. Они позволяют обновлять клиент в реальном или почти реальном времени, особенно когда WebSockets недоступны.

---

## Polling (Обычный опрос)

Клиент периодически опрашивает сервер: «Есть что-то новенькое?»

### Как работает polling

- Клиент отправляет запрос `GET /data`
- Сервер сразу отвечает, даже если нет новых данных
- Через заданный интервал клиент посылает следующий запрос

```js
setInterval(() => {
  fetch('/data')
    .then((res) => res.json())
    .then((data) => console.log(data));
}, 5000); // Запрос каждые 5 секунд
```

### Минусы polling

- Постоянная нагрузка на сервер (много лишних запросов)
- Данные приходят с задержкой
- Плохая масштабируемость

---

## Long Polling (Длинный опрос)

Улучшенная версия polling: запрос держится до появления новых данных.

### Как работает long polling

- Клиент посылает запрос
- Сервер ждёт появления данных или тайм-аута
- Отдаёт данные, после чего клиент сразу же отправляет новый запрос

```js
function longPolling() {
  fetch('/data')
    .then((res) => res.json())
    .then((data) => {
      console.log(data);
      longPolling(); // Продолжаем цикл
    });
}

longPolling();
```

### Плюсы long polling

- Меньше пустых запросов
- Почти мгновенная доставка данных
- Работает по обычному HTTP, не требует новых протоколов

### Минусы long polling

- Всё ещё задержка при получении данных
- Сложнее масштабировать

---

## Server-Sent Events (SSE)

SSE — постоянное соединение, по которому сервер отправляет данные в клиент в момент их появления. Однонаправленное — сервер → клиент.

### Как работает SSE

- Клиент создаёт объект `EventSource`
- Сервер выставляет заголовок `text/event-stream`
- Сервер отправляет сообщения когда нужно, без запроса клиента

### Пример (Клиент)

```js
const eventSource = new EventSource('/events');

eventSource.onmessage = (event) => {
  console.log('Новое сообщение:', event.data);
};
```

### Пример (Сервер на Express)

```js
app.get('/events', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  setInterval(() => {
    res.write(`data: ${JSON.stringify({ time: new Date() })}\n\n`);
  }, 3000);
});
```

### Преимущества SSE

- Простая реализация
- Работает по одному постоянному соединению
- Подходит для уведомлений, чатов, потоковой передачи данных
- Поддерживает работу через прокси и HTTP/2

---

## Сравнение методов

| Метод        | Направление     | Постоянное соединение | Мгновенность | Сложность | Поддержка            |
| ------------ | --------------- | --------------------- | ------------ | --------- | -------------------- |
| Polling      | Клиент → Сервер | Нет                   | Нет          | Простая   | Все браузеры         |
| Long Polling | Клиент → Сервер | Временно              | Почти        | Средняя   | Все браузеры         |
| SSE          | Сервер → Клиент | Да                    | Да           | Средняя   | Почти все (кроме IE) |

---

## Что выбрать?

- **Polling:** если другие методы недоступны или данные не нужны чаще, чем раз в 30 секунд
- **Long Polling:** если нужны почти мгновенные данные, но SSE и WebSocket недоступны
- **SSE:** для однонаправленного real-time (уведомления, ленты, чаты)
- **WebSocket:** для двусторонней связи (игры, коллаборативные редакторы, видеочаты)

---

## Вывод

Polling — простой, но неэффективный.  
Long Polling — компромисс.  
SSE — отличное решение для real-time без WebSocket.

Выбор зависит от направления связи, нагрузки, требований к задержкам и поддержки браузеров.

---

Источник: [Server-Sent Events, Polling и Long Polling — hackfrontend](https://www.hackfrontend.com/docs/general-questions/server-sent-events-polling-long-polling)

[1](https://www.hackfrontend.com/docs/general-questions/server-sent-events-polling-long-polling)
