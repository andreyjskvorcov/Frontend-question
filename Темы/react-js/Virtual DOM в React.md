
---

# Virtual DOM в React

**Virtual DOM** — это облегчённая копия реального [DOM](https://www.hackfrontend.com/docs/html-and-css/what-is-a-dom), хранящаяся в оперативной памяти.  
React обновляет эту копию вместо непосредственного изменения реального DOM, чтобы не вызывать лишние _дорогие_ операции (layout, painting, reflow) в браузере.

Когда все изменения внесены, React сравнивает старую и новую версии Virtual DOM (_diffing_) и точечно обновляет реальный DOM (_reconciliation_).

---

### Эвристический алгоритм O(n)

React применяет эффективный алгоритм на основе двух предположений:

- **Разные типы элементов → разные деревья**  
  Если типы компонентов различаются, React уничтожает старое дерево и строит новое с нуля.  
  Если тип совпадает, обновляются только изменённые атрибуты и дочерние узлы.

- **Значение key для потомков**  
  При перестановке элементов в списке `key` помогает React понять:
  - какие элементы остались,
  - какие добавились,
  - какие удалились.

Это сокращает количество ненужных перерисовок.

---

### Шаги обновления (упрощённо)

1. **Обновление Virtual DOM**  
   Изменения фиксируются (например, вызов `setState` или `useState`).

2. **Diffing**  
   React сравнивает предыдущий Virtual DOM с новым.

3. **Reconciliation**  
   В реальном DOM обновляются только изменённые части.  
   Обновления React выполняет _пакетно_, а не после каждого мелкого изменения.

Подробнее: [Процесс обновления Virtual DOM (React Fiber)](https://www.hackfrontend.com/docs/react/react-fiber#процесс-обновления-virtual-dom)

---

### Ключевые моменты

- **Минимизация работы с реальным DOM** — React снижает нагрузку на браузер.
- **Инкапсуляция** — каждый компонент работает со своим состоянием.
- **Масштабируемость** — упрощает поддержку и развитие больших приложений.

⚠️ Важно: если рендерится родительский компонент, по умолчанию рендерятся и дочерние, если не применяются оптимизации (`React.memo`, `shouldComponentUpdate`).

---

### Примеры

#### Пример 1: Обновление текста в DOM напрямую (плохо)

```JS <code>
const element = document.getElementById("title");
element.textContent = "Привет, DOM!";
</code>
```

Здесь мы напрямую меняем реальный DOM, что может быть дорого при большом количестве таких операций.

---

#### Пример 2: Обновление с Virtual DOM (React)

```JS <code>
import React, { useState } from "react";

function App() {
  const [text, setText] = useState("Привет, React!");

  return (
    <div>
      <h1>{text}</h1>
      <button onClick={() => setText("Текст изменён!")}>
        Изменить
      </button>
    </div>
  );
}

export default App;
</code>
```

Здесь React меняет Virtual DOM → сравнивает его с предыдущим → обновляет только изменённый текст в реальном DOM.

---

#### Пример 3: Оптимизация с `key` при списках

```JS <code>
import React from "react";

function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.value}</li>
      ))}
    </ul>
  );
}
</code>
```

Использование `key` помогает React эффективно понимать, какие элементы нужно перерисовать, а какие можно переиспользовать.

---

Хочешь, я добавлю ещё **визуальное сравнение** "Реальный DOM vs Virtual DOM" с табличкой для наглядности?

[1](https://www.hackfrontend.com/docs/html-and-css/what-is-a-dom)
