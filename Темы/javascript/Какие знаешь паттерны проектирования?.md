Паттерны проектирования — это проверенные решения типичных задач проектирования программного обеспечения, которые помогают создавать гибкую, поддерживаемую и расширяемую архитектуру приложений. Они делятся на три большие группы: порождающие, структурные и поведенческие.

---

### Основные паттерны проектирования с примерами и архитектурой

| Группа            | Паттерн                                            | Описание                                                                                               | Пример                                                 |
| ----------------- | -------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ |
| **Порождающие**   | **Singleton (Одиночка)**                           | Обеспечивает создание единственного экземпляра класса и глобальный доступ к нему                       | Класс настроек приложения с единственным инстансом     |
|                   | **Factory Method (Фабрика)**                       | Определяет интерфейс для создания объекта, позволяя подклассам решать, какой класс инстанцировать      | Фабрика для создания разных видов уведомлений          |
|                   | **Abstract Factory**                               | Предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания конкретных классов | Интерфейс для создания UI-компонентов с разными темами |
|                   | **Builder (Строитель)**                            | Позволяет создавать сложные объекты пошагово                                                           | Конструктор сложного запроса SQL                       |
|                   | **Prototype (Прототип)**                           | Создаёт новые объекты копированием существующих                                                        | Клонирование конфигураций                              |
| **Структурные**   | **Adapter (Адаптер)**                              | Преобразует интерфейс класса в другой, ожидаемый клиентом                                              | Обёртка над сторонним API                              |
|                   | **Decorator (Декоратор)**                          | Динамически расширяет функциональность объекта                                                         | Добавление логирования или кэширования к функциям      |
|                   | **Facade (Фасад)**                                 | Обеспечивает унифицированный интерфейс к сложной подсистеме                                            | Упрощённый API для работы с несколькими сервисами      |
|                   | **Proxy (Прокси)**                                 | Контролирует доступ к объекту, добавляя функциональность                                               | Ленивое создание объекта или ограничение доступа       |
|                   | **Composite (Компоновщик)**                        | Позволяет сгруппировать объекты и работать с ними как с одним объектом                                 | Дерево UI-компонентов                                  |
| **Поведенческие** | **Observer (Наблюдатель)**                         | Организует уведомление зависимых объектов об изменениях                                                | Подписка на события пользовательского интерфейса       |
|                   | **Strategy (Стратегия)**                           | Определяет семейство алгоритмов и позволяет менять их во время выполнения                              | Разные способы сортировки данных                       |
|                   | **Command (Команда)**                              | Инкапсулирует запрос как объект, позволяя параметризовать клиентов                                     | Undo/Redo в текстовом редакторе                        |
|                   | **Iterator (Итератор)**                            | Позволяет последовательно обходить элементы коллекции                                                  | Цикл обхода элементов массива или списка               |
|                   | **Chain of Responsibility (Цепочка обязанностей)** | Передаёт запрос по цепочке обработчиков                                                                | Обработка событий с несколькими уровнями в UI          |

---

### Пример паттерна Singleton на JavaScript

```js
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    this.value = Math.random();
    Singleton.instance = this;
  }
}

const a = new Singleton();
const b = new Singleton();

console.log(a === b); // true — один и тот же экземпляр
```

---

### Архитектура с использованием паттернов

В типичном веб-приложении:

- **Singleton** можно использовать для управления состоянием приложения или конфигурацией.
- **Observer** — для подписки компонентов на изменения глобального состояния или событий.
- **Factory** — для создания компонентов UI или API-клиентов с разными параметрами.
- **Facade** — для упрощения взаимодействия с внешними библиотеками или сервисами.
- **Decorator** — для динамического добавления логики (например, кеширование, логирование).

---

### Итог

Паттерны проектирования помогают структурировать код, делая архитектуру приложения гибкой, удобной для расширения и сопровождения. Владение ими существенно повышает качество и надёжность разработки программных систем. Их использование в сочетании с современными технологиями фронтенда и бэкенда обеспечивает устойчивость и масштабируемость проектов.

Ниже приведён пример для каждого из основных паттернов проектирования с коротким пояснением и иллюстрацией на JavaScript:

---

### Порождающие паттерны

**Singleton (Одиночка)**  
Гарантирует создание только одного экземпляра класса.

```js
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    this.value = Math.random();
    Singleton.instance = this;
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
```

---

**Factory Method (Фабрика)**  
Создаёт объекты, скрывая конкретные классы.

```js
class Car {
  drive() {
    console.log('Еду');
  }
}
class Truck {
  drive() {
    console.log('Вожу груз');
  }
}

function vehicleFactory(type) {
  if (type === 'car') return new Car();
  if (type === 'truck') return new Truck();
}

const myVehicle = vehicleFactory('truck');
myVehicle.drive(); // Вожу груз
```

---

**Abstract Factory (Абстрактная Фабрика)**  
Создаёт семейство связанных объектов.

```js
class LightThemeButton {
  render() {
    console.log('Светлая кнопка');
  }
}
class DarkThemeButton {
  render() {
    console.log('Тёмная кнопка');
  }
}

class LightThemeFactory {
  createButton() {
    return new LightThemeButton();
  }
}

class DarkThemeFactory {
  createButton() {
    return new DarkThemeButton();
  }
}

function getFactory(theme) {
  return theme === 'dark' ? new DarkThemeFactory() : new LightThemeFactory();
}

const factory = getFactory('dark');
const button = factory.createButton();
button.render(); // Тёмная кнопка
```

---

**Builder (Строитель)**  
Пошаговое создание сложного объекта.

```js
class BurgerBuilder {
  constructor() {
    this.burger = {};
  }
  addBun(bun) {
    this.burger.bun = bun;
    return this;
  }
  addPatty(patty) {
    this.burger.patty = patty;
    return this;
  }
  addSauce(sauce) {
    this.burger.sauce = sauce;
    return this;
  }
  build() {
    return this.burger;
  }
}

const burger = new BurgerBuilder()
  .addBun('Булочка')
  .addPatty('Котлета')
  .addSauce('Майонез')
  .build();

console.log(burger);
```

---

**Prototype (Прототип)**  
Создает объекты копированием существующих.

```js
const car = {
  wheels: 4,
  drive() {
    console.log('Еду');
  },
};

const carClone = Object.create(car);
carClone.drive(); // Еду
console.log(carClone.wheels); // 4
```

---

### Структурные паттерны

**Adapter (Адаптер)**  
Преобразует интерфейс одного класса в другой.

```js
class OldApi {
  specificRequest() {
    return 'Специфичный ответ от старого API';
  }
}

class Adapter {
  constructor() {
    this.oldApi = new OldApi();
  }
  request() {
    return this.oldApi.specificRequest();
  }
}

const adapter = new Adapter();
console.log(adapter.request()); // Специфичный ответ от старого API
```

---

**Decorator (Декоратор)**  
Добавляет поведение объекту динамически.

```js
function logger(target, name, descriptor) {
  const original = descriptor.value;
  descriptor.value = function (...args) {
    console.log(`Вызов ${name} с аргументами:`, args);
    return original.apply(this, args);
  };
  return descriptor;
}

class User {
  @logger
  sayHi(name) {
    return `Привет, ${name}`;
  }
}

const user = new User();
console.log(user.sayHi('Алиса'));
// Вызов sayHi с аргументами: [ 'Алиса' ]
// Привет, Алиса
```

---

**Facade (Фасад)**  
Упрощённый интерфейс к сложной системе.

```js
class CPU {
  freeze() {
    console.log('CPU заморожен');
  }
  jump(position) {
    console.log(`Прыжок на позицию ${position}`);
  }
  execute() {
    console.log('Выполнение');
  }
}

class Memory {
  load(position, data) {
    console.log(`Загрузка данных в память по адресу ${position}`);
  }
}

class HardDrive {
  read(position, size) {
    return 'данные';
  }
}

class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hd = new HardDrive();
  }
  start() {
    this.cpu.freeze();
    this.memory.load(0, this.hd.read(0, 1024));
    this.cpu.jump(0);
    this.cpu.execute();
  }
}

const computer = new ComputerFacade();
computer.start();
```

---

**Proxy (Прокси)**  
Контролирует доступ к объекту.

```js
const service = {
  getData() {
    console.log('Получение данных');
  },
};

const proxy = new Proxy(service, {
  get(target, prop) {
    if (prop === 'getData') {
      console.log('Проверка доступа перед вызовом getData');
      return target[prop];
    }
    return target[prop];
  },
});

proxy.getData();
// Проверка доступа перед вызовом getData
// Получение данных
```

---

**Composite (Компоновщик)**  
Работает с деревьями объектов одинаковым образом.

```js
class Leaf {
  operation() {
    console.log('Лист');
  }
}

class Composite {
  constructor() {
    this.children = [];
  }
  add(child) {
    this.children.push(child);
  }
  operation() {
    this.children.forEach((child) => child.operation());
  }
}

const root = new Composite();
const leaf1 = new Leaf();
const leaf2 = new Leaf();

root.add(leaf1);
root.add(leaf2);

root.operation();
// Лист
// Лист
```

---

### Поведенческие паттерны

**Observer (Наблюдатель)**  
Уведомляет подписчиков об изменениях.

```js
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  notify(data) {
    this.observers.forEach((o) => o.update(data));
  }
}

class Observer {
  update(data) {
    console.log('Обновлено:', data);
  }
}

const subject = new Subject();
const observer = new Observer();

subject.subscribe(observer);
subject.notify('Новое событие');
```

---

**Strategy (Стратегия)**  
Выбирает алгоритм во время выполнения.

```js
class Context {
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  execute(a, b) {
    return this.strategy(a, b);
  }
}

const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

const context = new Context();

context.setStrategy(add);
console.log(context.execute(2, 3)); // 5

context.setStrategy(multiply);
console.log(context.execute(2, 3)); // 6
```

---

**Command (Команда)**  
Инкапсулирует запрос как объект.

```js
class Command {
  constructor(execute) {
    this.execute = execute;
  }
}

class Invoker {
  constructor() {
    this.commands = [];
  }
  storeCommand(command) {
    this.commands.push(command);
  }
  run() {
    this.commands.forEach((cmd) => cmd.execute());
  }
}

const sayHi = new Command(() => console.log('Привет'));
const invoker = new Invoker();

invoker.storeCommand(sayHi);
invoker.run(); // Привет
```

---

**Iterator (Итератор)**  
Позволяет последовательно перебирать элементы.

```js
function iterator(collection) {
  let index = 0;
  return {
    next() {
      return index < collection.length
        ? { value: collection[index++], done: false }
        : { done: true };
    },
  };
}

const it = iterator([1, 2, 3]);
console.log(it.next()); // {value:1, done:false}
console.log(it.next()); // {value:2, done:false}
console.log(it.next()); // {value:3, done:false}
console.log(it.next()); // {done:true}
```

---

**Chain of Responsibility (Цепочка обязанностей)**  
Передаёт запрос по цепочке обработчиков.

```js
class Handler {
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

class ConcreteHandler1 extends Handler {
  handle(request) {
    if (request === 'A') return 'Handled by ConcreteHandler1';
    return super.handle(request);
  }
}

class ConcreteHandler2 extends Handler {
  handle(request) {
    if (request === 'B') return 'Handled by ConcreteHandler2';
    return super.handle(request);
  }
}

const handler1 = new ConcreteHandler1();
const handler2 = new ConcreteHandler2();

handler1.setNext(handler2);

console.log(handler1.handle('B')); // Handled by ConcreteHandler2
```

---

Эти примеры показывают реализацию основных паттернов проектирования и дают базовые идеи по их применению и архитектуре.
