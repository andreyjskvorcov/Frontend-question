В JavaScript с появлением стандарта ES2020 и позже стало возможно объявлять **настоящие приватные свойства и методы** классов с помощью префикса `#`. Это новая синтаксическая возможность, которая реализует настоящий инкапсулированный (закрытый) доступ к данным внутри класса, напрямую поддерживаемая самим языком.

---

### Что было раньше?

Раньше, чтобы показать, что свойство класса приватное, разработчики просто добавляли перед именем символ подчёркивания `_` — например, `this._money`. Это было **правило соглашения**, не имеющее реального ограничения: все такие свойства оставались публичными и можно было получить к ним доступ из-за пределов класса.

---

### Новый синтаксис с `#`

- Символ `#` в начале имени свойства или метода означает, что это **настоящие закрытые (private) поле или метод**.
- К таким полям нельзя получить доступ снаружи класса (даже попытка обратиться к ним вызывает **синтаксическую ошибку**).
- Доступ к таким полям разрешён только внутри класса, используя `this.#fieldName`.

### Пример:

```js
class Person {
  #money = 1; // приватное поле

  constructor(name) {
    this.name = name; // публичное свойство
  }

  // геттер для доступа к private свойству
  get money() {
    return this.#money;
  }

  // сеттер для изменения private свойства
  set money(value) {
    this.#money = value;
  }

  // метод, внутри которого можно обращаться к приватному полю
  showMoney() {
    console.log(this.#money);
  }
}

const p1 = new Person("fatfish");

console.log(p1.money); // 1 (через геттер)

// p1.#money = 2;  // Ошибка: нельзя получить доступ к private свойству напрямую

p1.money = 2; // изменение через сеттер

console.log(p1.money); // 2
// console.log(p1.#money); // Ошибка: доступ запрещён
```

---

### Основные особенности и правила

- Приватные поля объявляются с `#` **только внутри тела класса**.
- Они **не видны** снаружи, обращение к ним вне класса является синтаксической ошибкой (а не просто runtime-ошибкой).
- Нельзя динамически обратиться к таким свойствам через `obj["#money"]` или `obj.#money` снаружи.
- Защита инкапсуляции реализуется языком, а не соглашением.
- Приватные поля поддерживают инициализацию при объявлении или в конструкторе.
- Приватными можно сделать не только поля, но и методы, get/set аксессоры.

---

### Почему это полезно?

- Позволяет создавать **настоящие инкапсулированные данные**, которые гарантированно защищены от внешнего доступа.
- Избавляет от проблем с ненамеренным изменением свойств извне.
- Повышается безопасность и контроль над внутренним состоянием объекта.
- Улучшает чистоту и читаемость кода, делая публичные и приватные части чётко разделёнными.

---

### Краткое сравнение приватности

| Префикс          | Доступность                      | Реальная приватность      | Особенности                     |
| ---------------- | -------------------------------- | ------------------------- | ------------------------------- |
| `_` (underscore) | публичное, соглашение            | Нет, доступно извне       | Используется по соглашению      |
| `#` (hash)       | приватное, язык запрещает доступ | Да, синтаксически закрыто | Только внутри класса via `this` |

---

Таким образом, современный синтаксис с `#` — это теперь чистый, встроенный в язык способ реализовать **настоящую приватность** для свойств и методов в классах JavaScript, в отличие от старых соглашений с подчёркиванием.[2][5][6][7]

[1](https://stackoverflow.com/questions/79132473/how-to-declare-a-true-private-field-with-symbol)
[2](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements)
[3](https://mrotaru.co.uk/blog/javascript-private-properties)
[4](https://mitya.uk/articles/using-symbols-private-properties)
[5](https://www.js-craft.io/blog/javascript-how-to-declare-private-properties-and-methods/)
[6](https://ultimatecourses.com/blog/private-properties-methods-javascript-classes)
[7](https://dev.to/smitterhane/private-class-fields-in-javascript-es2022-3b8)
[8](https://www.c-sharpcorner.com/article/javascript-symbols-unique-identifiers-and-private-properties/)
