?

---

Что такое функции высшего порядка?

Функции высшего порядка — это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата. Это позволяет писать более модульный, читаемый и переиспользуемый код.

---

### Примеры и дополнения

#### 1. Callback — функция, переданная как аргумент

```js
function calculate(num1, num2, operation) {
  return operation(num1, num2);
}

function add(a, b) {
  return a + b;
}

function multiply(a, b) {
  return a * b;
}

console.log(calculate(5, 3, add)); // 8
console.log(calculate(5, 3, multiply)); // 15
```

---

#### 2. Функция-обертка (Wrapper, или декоратор)

Оборачивает функцию дополнительной логикой.

```js
function withLogging(func) {
  return function (...args) {
    console.log("Calling function:", func.name);
    const result = func(...args);
    console.log("Result:", result);
    return result;
  };
}

function multiply(a, b) {
  return a * b;
}

const wrappedMultiply = withLogging(multiply);

console.log(wrappedMultiply(5, 3)); // Calling function: multiply, Result: 15, 15
```

---

### Применение функций высшего порядка в Vue.js

- Реактивные вычисляемые свойства и watchers часто используют callback-функции:

```js
watch(someRef, (newVal, oldVal) => {
  console.log("Значение изменилось", newVal);
});
```

- Создание функциональных компонентов и хуков — пример высшего порядка:

```js
function useToggle(initial = false) {
  const state = ref(initial);
  const toggle = () => (state.value = !state.value);
  return [state, toggle];
}
```

---

### Пример HOC (Higher-Order Component) в React

Функция, которая принимает компонент и возвращает новый с дополнительным функционалом:

```js
function withLoading(Component) {
  return function WrappedComponent({ isLoading, ...props }) {
    if (isLoading) return <div>Loading...</div>;
    return <Component {...props} />;
  };
}

// Использование
const UserListWithLoading = withLoading(UserList);
```

---

### Использование функций высшего порядка в Nuxt.js

- Middleware и плагины часто принимают функции для расширения логики:

```js
export default function ({ route, redirect }) {
  if (route.path === "/admin") {
    redirect("/login");
  }
}
```

- Создание универсальных утилит через высшие функции:

```js
function createApiHandler(endpoint) {
  return async function fetchData(params) {
    const res = await fetch(`${endpoint}?${new URLSearchParams(params)}`);
    return res.json();
  };
}

const getUserData = createApiHandler("/api/users");
```

---

### Дополнительно: Функция, возвращающая функцию (каррирование)

```js
function multiply(a) {
  return function (b) {
    return a * b;
  };
}

const double = multiply(2);
console.log(double(5)); // 10
```

---

Функции высшего порядка — основа функционального программирования, широко используемая в современных фреймворках и библиотеках для построения компонентов, обработки событий, создания хелперов и middleware.

Вот более продвинутые примеры и паттерны использования функций высшего порядка (ФВП) в Vue, React и Nuxt, а также советы по их применению:

---

### Продвинутые паттерны на базе функций высшего порядка

#### Vue.js: Создание пользовательского хука с реактивностью (Composition API)

```js
import { ref, watchEffect } from "vue";

function useDebounce(value, delay = 300) {
  const debouncedValue = ref(value.value);

  let timeout;
  watchEffect(() => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      debouncedValue.value = value.value;
    }, delay);
  });

  return debouncedValue;
}

// Использование в компоненте:
import { ref } from "vue";

export default {
  setup() {
    const searchQuery = ref("");
    const debouncedQuery = useDebounce(searchQuery, 500);

    watch(debouncedQuery, (val) => {
      console.log("Выполнить API-запрос с:", val);
    });

    return { searchQuery };
  },
};
```

Это пример пользовательской функции высшего порядка — она принимает реактивное значение и параметры, возвращая новое реактивное значение с задержкой.

---

#### React: HOC с условной отрисовкой и логикой авторизации

```js
function withAuth(WrappedComponent) {
  return function (props) {
    const isLoggedIn = useAuth(); // кастомный хук для авторизации
    if (!isLoggedIn) {
      return <Redirect to="/login" />;
    }
    return <WrappedComponent {...props} />;
  };
}

// Использование
const ProfileWithAuth = withAuth(Profile);
```

Это расширяет компонент `Profile`, добавляя логику защиты роутов.

---

#### Nuxt.js: Middleware как функция высшего порядка

```js
export default function (authRequired) {
  return function (context) {
    if (authRequired && !context.store.state.user) {
      context.redirect('/login');
    }
  };
}

// Применение с параметрами
export const authMiddleware = authRequired => export default function(ctx) {
  if (authRequired && !ctx.store.state.user) ctx.redirect('/login');
};

```

Позволяет создавать конфигурируемые middleware, принимающие параметры, что делает код более универсальным.

---

### Советы по использованию функций высшего порядка

- Используй функции высшего порядка для повторного использования логики, избегая дублирования.
- Для UI-компонентов применяй HOC или рендер-пропсы в React, и composables в Vue.
- В Nuxt используйте функции высшего порядка для создания параметризованных middleware и плагинов.
- Внимательно следи за производительностью: чрезмерное вложение ФВП или оберток может замедлить приложение.
- Пользовательские хуки и утилиты с ФВП делают код чище и легче поддерживаемым.

---

Дополняю с шаблонами и генераторами кодов для функций высшего порядка (ФВП) в Vue, React и Nuxt, чтобы упростить типовые задачи и увеличить переиспользуемость.

---

### Vue.js — шаблон пользовательского composable (функции высшего порядка)

```js
// useToggle.js — универсальный хук для переключения состояния
import { ref } from "vue";

export function useToggle(initial = false) {
  const state = ref(initial);
  function toggle() {
    state.value = !state.value;
  }
  return { state, toggle };
}

// Использование в компоненте
import { useToggle } from "./useToggle";

export default {
  setup() {
    const { state: isOpen, toggle } = useToggle();
    return { isOpen, toggle };
  },
};
```

---

### React — шаблон HOC для логирования вызовов функции

```js
function withLog(WrappedComponent) {
  return function (props) {
    console.log(`Rendering ${WrappedComponent.name}`);
    return <WrappedComponent {...props} />;
  };
}

// Использование
const ButtonWithLog = withLog(Button);
```

---

### Nuxt.js — создание параметризованного middleware через ФВП

```js
// middleware/auth.js
export default function (authRequired = true) {
  return function (context) {
    if (authRequired && !context.store.state.user) {
      return context.redirect("/login");
    }
  };
}

// В nuxt.config.js или страницах
export const middleware = authMiddleware(true);
```

---

### Генератор функций высшего порядка для асинхронной обработки ошибок

```js
function withErrorHandler(asyncFunc) {
  return async function (...args) {
    try {
      return await asyncFunc(...args);
    } catch (error) {
      console.error("Ошибка:", error);
      throw error;
    }
  };
}

// Пример в Vue/Nuxt/React
async function fetchData() {
  // ... запрос к API
}

const safeFetchData = withErrorHandler(fetchData);
safeFetchData().catch(() => {
  /* обработка на уровне вызова */
});
```

---

Эти шаблоны и генераторы помогают стандартизировать функциональность, сделать код более декларативным, понятным и удобным для масштабирования.

Добавляю конкретные генераторы и паттерны функций высшего порядка (ФВП) для типичных задач во Vue, React и Nuxt с примерами реального использования:

---

### Vue.js: Генератор универсального валидационного хука (ФВП для форм)

```js
import { reactive, ref } from "vue";

export function useValidator(rules) {
  const errors = reactive({});
  function validate(field, value) {
    errors[field] = null;
    const validators = rules[field] || [];
    for (const validateFn of validators) {
      const error = validateFn(value);
      if (error) {
        errors[field] = error;
        break;
      }
    }
    return !errors[field];
  }
  const validateAll = (form) => {
    let valid = true;
    for (const field in rules) {
      if (!validate(field, form[field])) valid = false;
    }
    return valid;
  };
  return { errors, validate, validateAll };
}

// Использование
const rules = {
  email: [
    (v) => /\S+@\S+\.\S+/.test(v) || "Неверный email",
    (v) => v.length > 5 || "Слишком короткий email",
  ],
  password: [(v) => v.length >= 6 || "Пароль должен быть минимум 6 символов"],
};
```

---

### React: HOC для кеширования результата асинхронного запроса

```js
function withCache(WrappedComponent, fetchData) {
  const cache = {};
  return class extends React.Component {
    state = { data: null, loading: true };

    async componentDidMount() {
      if (cache[this.props.id]) {
        this.setState({ data: cache[this.props.id], loading: false });
      } else {
        const data = await fetchData(this.props.id);
        cache[this.props.id] = data;
        this.setState({ data, loading: false });
      }
    }

    render() {
      return (
        <WrappedComponent
          {...this.props}
          data={this.state.data}
          loading={this.state.loading}
        />
      );
    }
  };
}
```

---

### Nuxt.js: Параметризованный плагин с повторным использованием логики

```js
// plugins/apiClient.js
import axios from "axios";

export default function ({ $config }, inject) {
  function createApiClient(baseURL) {
    const client = axios.create({ baseURL });
    return {
      get: (url) => client.get(url),
      post: (url, data) => client.post(url, data),
      // ... другие методы
    };
  }
  inject("apiClient", createApiClient($config.apiBaseUrl));
}
```

Использование в компонентах:

```js
export default {
  async asyncData({ app }) {
    const users = await app.$apiClient.get("/users");
    return { users: users.data };
  },
};
```

---

### Общие советы по генераторам ФВП

- Всегда старайтесь сделать ФВП максимально универсальными и параметризируемыми, чтобы они покрывали разные сценарии.
- Используйте замыкания и реактивные свойства (Vue) или state/props (React) для управления состоянием внутри ФВП.
- Документируйте ожидаемые аргументы и возвращаемые функции для удобства использования командой.
- Покрывайте ключевые ФВП юнит-тестами, чтобы гарантировать правильность при расширении и рефакторинге.

---

Вот пример комплексного проекта с использованием функций высшего порядка (ФВП) во Vue 3 + Nuxt 3, который включает управление формами, API-запросы и состояние с применением лучших практик.

---

### Структура и ключевые файлы проекта

```
/composables/useValidator.js      — Универсальный валидатор форм (ФВП)
/composables/useApiClient.js      — Абстракция API с кешированием (ФВП)
/components/BaseInput.vue          — Компонент поля ввода с валидацией
/pages/Register.vue                — Страница регистрации с применением композиционных функций и ФВП
/plugins/apiClient.js              — Плагин для подключения API клиента
```

---

### 1. useValidator.js — универсальный валидатор форм

```js
import { reactive } from "vue";

export function useValidator(rules) {
  const errors = reactive({});

  function validateField(field, value) {
    errors[field] = null;
    const validators = rules[field] || [];
    for (const validator of validators) {
      const error = validator(value);
      if (error) {
        errors[field] = error;
        break;
      }
    }
    return !errors[field];
  }

  function validateAll(form) {
    let valid = true;
    for (const field in rules) {
      if (!validateField(field, form[field])) {
        valid = false;
      }
    }
    return valid;
  }

  return { errors, validateField, validateAll };
}
```

---

### 2. useApiClient.js — обертка API с кешированием (ФВП)

```js
import { ref } from "vue";

export function useApiClient(api) {
  const cache = new Map();

  async function fetchWithCache(url) {
    if (cache.has(url)) {
      return cache.get(url);
    }
    const data = await api.get(url).then((res) => res.data);
    cache.set(url, data);
    return data;
  }

  return { fetchWithCache };
}
```

---

### 3. BaseInput.vue — реиспользуемый компонент с валидацией

```vue
<template>
  <div>
    <input v-model="modelValue" @input="onInput" :placeholder="placeholder" />
    <p v-if="error" class="error">{{ error }}</p>
  </div>
</template>

<script setup>
import { watch, toRef } from "vue";
const props = defineProps({
  modelValue: [String, Number],
  placeholder: String,
  error: String,
});
const emit = defineEmits(["update:modelValue"]);
function onInput(e) {
  emit("update:modelValue", e.target.value);
}
</script>

<style>
.error {
  color: red;
  font-size: 0.9em;
}
</style>
```

---

### 4. Register.vue — страница регистрации с использованием ФВП и хуков

```vue
<template>
  <form @submit.prevent="onSubmit">
    <BaseInput v-model="form.email" placeholder="Email" :error="errors.email" />
    <BaseInput
      v-model="form.password"
      type="password"
      placeholder="Пароль"
      :error="errors.password"
    />
    <button type="submit">Зарегистрироваться</button>
  </form>
</template>

<script setup>
import { reactive } from "vue";
import { useValidator } from "~/composables/useValidator";
import { useApiClient } from "~/composables/useApiClient";
import BaseInput from "~/components/BaseInput.vue";
import api from "~/plugins/apiClient";

const rules = {
  email: [
    (v) => /\S+@\S+\.\S+/.test(v) || "Неверный email",
    (v) => v.length > 5 || "Слишком короткий email",
  ],
  password: [(v) => v.length >= 6 || "Минимум 6 символов"],
};

const form = reactive({
  email: "",
  password: "",
});

const { errors, validateField, validateAll } = useValidator(rules);
const { fetchWithCache } = useApiClient(api);

async function onSubmit() {
  if (!validateAll(form)) return;
  try {
    const response = await api.post("/register", form);
    console.log("Успех", response.data);
  } catch (e) {
    console.error("Ошибка регистрации", e);
  }
}

// Валидация по изменению полей
watch(
  () => form.email,
  (val) => validateField("email", val)
);
watch(
  () => form.password,
  (val) => validateField("password", val)
);
</script>
```

---

### 5. apiClient.js — Nuxt плагин с axios

```js
import axios from "axios";

export default defineNuxtPlugin(() => {
  const api = axios.create({
    baseURL: useRuntimeConfig().public.apiBaseUrl,
  });
  return {
    provide: {
      api,
    },
  };
});
```

---

### Итог

- Компай модульная архитектура с использованием функций высшего порядка улучшает переиспользуемость и тестируемость.
- Чёткое разделение валидации, API-взаимодействия и UI-компонентов упрощает поддержку.
- В проектах Vue/Nuxt такой подход помогает создавать масштабируемые и устойчивые приложения.

---

Добавляю примеры и шаблоны с использованием функций высшего порядка (ФВП) в Vue 3 и Nuxt 3, включая шаблоны HOC в Vue, универсальные композиционные функции и лучшие практики из найденных репозиториев и статей.

---

### Высшие компоненты (HOC) в Vue 3 (пример из )[1]

```js
// WithCounter.js — HOC, добавляющий счётчик к компоненту
import { h, ref } from 'vue';

function WithCounter(WrappedComponent, incrementBy = 1) {
  return {
    setup() {
      const counter = ref(0);
      const increment = () => {
        counter.value += incrementBy;
      };

      return () =>
        h(WrappedComponent, {
          counter: counter.value,
          increment,
        });
    },
  };
}

export default WithCounter;

// Использование в компоненте
import WithCounter from './WithCounter';
import MyButton from './MyButton.vue';

export default {
  components: {
    CounterButton: WithCounter(MyButton, 5),
  },
};
```

---

### Универсальные composables и репозитории в Nuxt 3 (из ,)[2][3]

- Пример composable с инъекцией репозитория и API-слоем:

```ts
// composables/useUsers.ts
import { inject } from "vue";

export function useUsers() {
  const userRepository = inject("user-repository");
  if (!userRepository) throw new Error("User repository not provided");

  const list = () => userRepository.list();

  return { list };
}
```

- Внедрение репозитория через provide (например, в App.vue или отдельном конфигурационном провайдере)

```ts
import { provide } from "vue";

const userRepository = {
  list: () => fetch("/api/users").then((res) => res.json()),
};

export default {
  setup() {
    provide("user-repository", userRepository);
  },
};
```

---

### Nuxt плагин с функциональным API клиентом (пример из )[2]

```ts
// plugins/apiClient.ts
import axios from "axios";

export default defineNuxtPlugin(() => {
  const apiClient = axios.create({
    baseURL: useRuntimeConfig().public.apiBaseUrl,
  });

  return {
    provide: {
      apiClient,
    },
  };
});
```

---

### Советы и лучшие практики

- Используй HOC в Vue 3 для повторного использования логики создания компонентов, особенно при работе с рендер-функциями и функциональными компонентами.
- В Nuxt 3 активно применяй provide/inject и composables для реализации паттерна репозитория и разделения ответственности между API-слоем и UI.
- Для глобальной логики в Nuxt удобно использовать плагины с функциональными объектами (например, `apiClient`), которые внедряются в приложение через `provide`.
- Изучи шаблоны с Pinia для управления состоянием в Nuxt, они хорошо интегрируются с композиционным API и ФВП.

---

Вот ссылка на готовый репозиторий с примерами функций высшего порядка (ФВП) и современными паттернами во Vue 3 и Nuxt 3:

---

### Пример репозитория с HOC, Composables и Nuxt плагинами

- GitHub: [https://github.com/chakAs3/nuxt-storybook-composables-example](https://github.com/chakAs3/nuxt-storybook-composables-example)[1]

В этом репозитории показаны:

- Композиционные функции (Composables) с ФВП-логикой для работы с формами, API и состоянием
- Использование provide/inject для репозиториев и сервисов
- Пример написания плагинов для Nuxt с модульными API-клиентами
- Примеры высших компонентов (HOC) и паттернов повторного использования логики

---
